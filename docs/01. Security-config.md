# SecurityConfig.java — Complete Explanation in Very Easy Language

This is the MOST IMPORTANT file in Spring Security.

This file tells Spring:

• How security should work  
• Which URLs need login  
• Which URLs are public  
• How JWT authentication works  
• Which filter to use  
• How passwords are checked  

Without this file, Spring Security will NOT work properly.

---

# Full Code

```java
@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;
    private final UserDetailsService userDetailsService;

    @Bean
    public PasswordEncoder passwordEncoder() {

        return new BCryptPasswordEncoder();

    }

    @Bean
    public AuthenticationProvider authenticationProvider() {

        DaoAuthenticationProvider provider =
                new DaoAuthenticationProvider(userDetailsService);

        provider.setPasswordEncoder(passwordEncoder());

        return provider;

    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config)
            throws Exception {

        return config.getAuthenticationManager();

    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {

        http

                .csrf(csrf -> csrf.disable())

                .sessionManagement(session ->
                        session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )

                .authorizeHttpRequests(auth -> auth

                        .requestMatchers("/auth/**").permitAll()

                        .anyRequest().authenticated()

                )

                .authenticationProvider(authenticationProvider())

                .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();

    }

}
```

---

# PART 1: @Configuration

```java
@Configuration
```

Meaning:

This tells Spring:

"This class contains configuration."

Spring will run this class during startup.

Spring will create beans from this class.

Without this, Spring ignores this file.

---

# PART 2: @EnableWebSecurity

```java
@EnableWebSecurity
```

Meaning:

This enables Spring Security.

Spring loads security system.

Without this, security will not activate.

---

# PART 3: @RequiredArgsConstructor

```java
@RequiredArgsConstructor
```

This is from Lombok.

It automatically creates constructor like this:

```java
public SecurityConfig(
    JwtAuthenticationFilter jwtAuthenticationFilter,
    UserDetailsService userDetailsService
)
```

Spring uses this constructor to inject dependencies.

This is called Dependency Injection.

---

# PART 4: JwtAuthenticationFilter Field

```java
private final JwtAuthenticationFilter jwtAuthenticationFilter;
```

This is YOUR custom JWT filter.

This filter will:

• read JWT token  
• validate JWT token  
• authenticate user  

This filter runs for EVERY request.

Without this filter, JWT authentication will not work.

---

# PART 5: UserDetailsService Field

```java
private final UserDetailsService userDetailsService;
```

This service loads user from database.

Spring Security uses this during login.

Flow:

Login request  
→ AuthenticationManager  
→ AuthenticationProvider  
→ UserDetailsService  
→ UserRepository  
→ Database  

---

# PART 6: PasswordEncoder Bean

```java
@Bean
public PasswordEncoder passwordEncoder() {

    return new BCryptPasswordEncoder();

}
```

Purpose:

Encrypt passwords.

Example:

Input password:
```
1234
```

Stored in database:
```
$2a$10$sdlfjsldkfjlsdkfjsldkfj
```

This protects passwords.

Spring Security uses this to:

• encode password during register  
• verify password during login  

---

# PART 7: AuthenticationProvider Bean

```java
@Bean
public AuthenticationProvider authenticationProvider()
```

AuthenticationProvider checks username and password.

---

```java
DaoAuthenticationProvider provider =
        new DaoAuthenticationProvider(userDetailsService);
```

DaoAuthenticationProvider is default authentication provider.

It uses:

• UserDetailsService → load user  
• PasswordEncoder → verify password  

---

```java
provider.setPasswordEncoder(passwordEncoder());
```

Sets password encoder.

Used to compare password.

---

```java
return provider;
```

Spring registers this provider.

---

# PART 8: AuthenticationManager Bean

```java
@Bean
public AuthenticationManager authenticationManager(AuthenticationConfiguration config)
```

AuthenticationManager is used during login.

Example usage:

```java
authenticationManager.authenticate(
    new UsernamePasswordAuthenticationToken(username, password)
);
```

Spring automatically connects:

AuthenticationManager  
→ AuthenticationProvider  
→ UserDetailsService  
→ PasswordEncoder  

---

```java
return config.getAuthenticationManager();
```

Spring gives default AuthenticationManager.

---

# PART 9: SecurityFilterChain Bean (MOST IMPORTANT)

```java
@Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http)
```

This builds security system.

SecurityFilterChain is a list of filters.

Filters run for every request.

Example flow:

Request  
→ JWT Filter  
→ Authentication Filter  
→ Authorization Filter  
→ Controller  

---

# PART 10: Disable CSRF

```java
.csrf(csrf -> csrf.disable())
```

CSRF is used in session authentication.

JWT is stateless.

So we disable CSRF.

---

# PART 11: Stateless Session

```java
.sessionManagement(session ->
        session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
)
```

This tells Spring:

DO NOT use session.

JWT authentication does not use session.

Every request must send JWT token.

---

# PART 12: Authorization Rules

```java
.authorizeHttpRequests(auth -> auth
```

This defines access rules.

---

```java
.requestMatchers("/auth/**").permitAll()
```

These URLs are public:

```
/auth/register
/auth/login
```

Anyone can access.

No login required.

---

```java
.anyRequest().authenticated()
```

All other URLs require login.

Example:

```
/api/test
```

Requires JWT token.

---

# PART 13: Register AuthenticationProvider

```java
.authenticationProvider(authenticationProvider())
```

Registers authentication provider.

Spring uses this during login.

---

# PART 14: Register JWT Filter (VERY IMPORTANT)

```java
.addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);
```

This tells Spring:

Run JwtAuthenticationFilter BEFORE default authentication filter.

Flow:

Request  
→ JwtAuthenticationFilter  
→ UsernamePasswordAuthenticationFilter  
→ Controller  

JwtAuthenticationFilter authenticates user using JWT.

---

# PART 15: Build SecurityFilterChain

```java
return http.build();
```

Builds security system.

Spring activates security.

---

# COMPLETE FLOW EXPLAINED

Application starts  
→ Spring loads SecurityConfig  
→ SecurityFilterChain created  
→ JwtAuthenticationFilter registered  

User sends request  

JwtAuthenticationFilter runs  

If token valid  
→ User authenticated  

Controller executes  

Response returned  

---

# Real Example Flow

User sends request:

```
GET /api/test

Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
```

Flow:

JwtAuthenticationFilter runs  
→ extract token  

validate token  

set authentication  

Controller executes  

---

# Interview Questions

Q: Why SecurityConfig required?

Answer:

It configures Spring Security.

---

Q: Why disable CSRF?

Answer:

JWT is stateless.

---

Q: Why Stateless session?

Answer:

JWT does not use session.

---

Q: Why addFilterBefore?

Answer:

To authenticate user using JWT.

---

Q: What is AuthenticationProvider?

Answer:

Checks username and password.

---

# Summary in Simple Words

SecurityConfig is brain of Spring Security.

It tells Spring:

• how to authenticate  
• how to authorize  
• which filter to use  
• which URLs are public  
• which URLs are protected  

Without this file, JWT authentication will not work.
